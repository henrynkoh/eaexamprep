
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>커서 AI "더블 에이전트" 핵: 2배 빠른 코딩을 위한 궁극 가이드</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">커서 AI "더블 에이전트" 핵: 2배 빠른 코딩을 위한 궁극 가이드</h2>
                                <div class="box-info">
                                    <p class="category">IT</p>
                                    <p class="date">2025-02-14 07:14:02</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <h2 data-ke-size="size26">"Double&nbsp;Agent"&nbsp;hack&nbsp;with&nbsp;Cursor&nbsp;to&nbsp;code&nbsp;faster.</h2>
<h1>커서 AI "더블 에이전트" 핵: 2배 빠른 코딩을 위한 궁극 가이드 (feat. GitHub &amp; Git Worktree)</h1>
<p data-ke-size="size16">AI 코딩 도구의 발전으로 개발 속도가 눈에 띄게 향상되었지만, 여전히 AI가 코드를 생성하고 수정하는 데 걸리는 시간을 기다리는 것이 답답하게 느껴질 때가 있습니다. 하지만 이제 걱정 마세요! 본 글에서는 커서(Cursor) AI 에이전트를 두 개 동시에 실행하여 코딩 속도를 2배로 높이는 획기적인 방법, 일명 "더블 에이전트" 핵을 소개합니다. GitHub와 Git Worktree를 활용하여 AI 에이전트 간의 충돌을 방지하고 효율적인 협업을 가능하게 하는 이 놀라운 방법을 지금 바로 알아보세요.</p>
<h2 data-ke-size="size26">1. "더블 에이전트" 핵이란 무엇인가?</h2>
<p data-ke-size="size16">"더블 에이전트" 핵은 하나의 코드베이스에서 두 개의 커서 AI 에이전트를 동시에 실행하여 코드 개발 속도를 획기적으로 향상시키는 방법입니다. GitHub의 버전 관리 시스템과 Git Worktree를 활용하여 각 에이전트가 독립적인 환경에서 작업하도록 함으로써 코드 충돌을 방지하고 효율적인 협업을 가능하게 합니다.</p>
<h2 data-ke-size="size26">2. "더블 에이전트" 핵의 핵심 원리</h2>
<h3 data-ke-size="size23">2.1. GitHub 버전 관리 시스템</h3>
<p data-ke-size="size16">GitHub는 코드의 변경 사항을 추적하고 관리하는 버전 관리 시스템입니다. 여러 개발자가 동시에 작업하더라도 코드 충돌을 방지하고 효율적인 협업을 가능하게 합니다. "더블 에이전트" 핵은 이러한 GitHub의 버전 관리 기능을 적극 활용합니다.</p>
<h3 data-ke-size="size23">2.2. Git Worktree</h3>
<p data-ke-size="size16">Git Worktree는 Git 저장소의 여러 브랜치를 동시에 체크아웃하여 작업할 수 있도록 해주는 기능입니다. 이를 통해 하나의 저장소를 여러 개의 로컬 폴더에 연결하여 각 폴더에서 독립적인 작업을 수행할 수 있습니다. "더블 에이전트" 핵에서는 각 커서 AI 에이전트가 Git Worktree를 통해 생성된 별도의 폴더에서 작업하도록 하여 코드 충돌을 원천적으로 방지합니다.</p>
<h3 data-ke-size="size23">2.3. AI 에이전트 간 협업</h3>
<p data-ke-size="size16">각 AI 에이전트는 독립적인 환경에서 작업을 수행하지만, GitHub를 통해 변경 사항을 공유하고 병합할 수 있습니다. 이를 통해 AI 에이전트들은 마치 숙련된 개발자들처럼 협업하여 코드 개발을 진행할 수 있습니다.</p>
<h2 data-ke-size="size26">3. "더블 에이전트" 핵 설정 방법: 30단계 가이드</h2>
<p data-ke-size="size16">다음은 "더블 에이전트" 핵을 설정하는 방법을 30단계로 세분화한 가이드입니다.</p>
<p data-ke-size="size16"><b>준비물:</b></p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>커서(Cursor) AI 코드 편집기</li>
<li>GitHub 계정</li>
<li>Git 명령줄 도구</li>
</ul>
<p data-ke-size="size16"><b>단계별 설정:</b></p>
<ol style="list-style-type: decimal;" data-ke-list-type="decimal">
<li><b>GitHub 저장소 생성:</b> GitHub에 새로운 저장소를 생성합니다.</li>
<li><b>로컬 저장소 복제:</b> 생성한 GitHub 저장소를 로컬 컴퓨터로 복제합니다.</li>
<li><b>초기 코드 추가:</b> 복제한 로컬 저장소에 초기 코드를 추가합니다. (강의 영상에서는 React ShadCN 데모 코드를 사용)</li>
<li><b>초기 코드 커밋 및 푸시:</b> 추가한 초기 코드를 GitHub 저장소의 메인 브랜치에 커밋하고 푸시합니다.</li>
<li><b>새 브랜치 생성 (Dev A, Dev B):</b> Git 명령줄 도구를 사용하여 개발용 브랜치 "Dev A"와 "Dev B"를 생성합니다.
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>git branch DevA</li>
<li>git branch DevB</li>
</ul>
</li>
<li><b>원격 저장소에 브랜치 푸시:</b> 생성한 개발용 브랜치를 원격 GitHub 저장소에 푸시합니다.
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>git push origin DevA</li>
<li>git push origin DevB</li>
</ul>
</li>
<li><b>Git Worktree 생성 (Game Center A, Game Center B):</b> Git Worktree를 사용하여 "Dev A" 브랜치를 "Game Center A" 폴더에, "Dev B" 브랜치를 "Game Center B" 폴더에 연결합니다.
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>git worktree add GameCenterA origin/DevA</li>
<li>git worktree add GameCenterB origin/DevB</li>
</ul>
</li>
<li><b>커서 AI 실행:</b> 커서 AI 코드 편집기를 두 개 실행합니다.</li>
<li><b>각 폴더에 프로젝트 열기:</b> 각 커서 AI 에이전트에서 "Game Center A" 폴더와 "Game Center B" 폴더를 각각 엽니다.</li>
<li><b>종속성 설치:</b> 각 폴더에서 터미널을 열고 종속성을 설치합니다.
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>npm install</li>
</ul>
</li>
<li><b>포트 번호 변경 (Game Center B):</b> "Game Center B" 폴더에서 실행되는 애플리케이션의 포트 번호를 변경합니다. (기본 포트 충돌 방지)</li>
<li><b>애플리케이션 실행:</b> 각 폴더에서 애플리케이션을 실행합니다.
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>npm run dev (Game Center A)</li>
<li>npm run dev (Game Center B, 변경된 포트 번호로 실행)</li>
</ul>
</li>
<li><b>AI 에이전트 작업 지시 (Game Center A):</b> "Game Center A" 폴더에서 실행되는 커서 AI 에이전트에게 특정 작업을 지시합니다. (예: 메모리 게임 구현)
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li><b>프롬프트 예시</b>: "메모리 게임을 구현하고, 이 파일을 중앙 파일과 통합해주세요."</li>
</ul>
</li>
<li><b>AI 에이전트 작업 지시 (Game Center B):</b> "Game Center B" 폴더에서 실행되는 커서 AI 에이전트에게 다른 작업을 지시합니다. (예: 스네이크 게임 구현)
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li><b>프롬프트 예시</b>: "스네이크 게임을 구현하고, 이 파일을 중앙 파일과 통합해주세요."</li>
</ul>
</li>
<li><b>결과 확인 (Game Center A):</b> "Game Center A" 폴더에서 AI 에이전트가 구현한 메모리 게임을 확인합니다.</li>
<li><b>결과 확인 (Game Center B):</b> "Game Center B" 폴더에서 AI 에이전트가 구현한 스네이크 게임을 확인합니다.</li>
<li><b>변경 사항 수락 (Game Center A):</b> "Game Center A" 폴더에서 변경 사항을 모두 수락합니다.</li>
<li><b>변경 사항 커밋 및 푸시 (Game Center A):</b> "Game Center A" 폴더에서 변경 사항을 커밋하고 "Dev A" 브랜치에 푸시합니다.</li>
<li><b>변경 사항 수락 (Game Center B):</b> "Game Center B" 폴더에서 변경 사항을 모두 수락합니다.</li>
<li><b>변경 사항 커밋 및 푸시 (Game Center B):</b> "Game Center B" 폴더에서 변경 사항을 커밋하고 "Dev B" 브랜치에 푸시합니다.</li>
<li><b>GitHub에서 풀 리퀘스트 생성 (Dev B -&gt; Main):</b> GitHub에서 "Dev B" 브랜치를 "Main" 브랜치에 병합하기 위한 풀 리퀘스트를 생성합니다.</li>
<li><b>풀 리퀘스트 병합 (Dev B -&gt; Main):</b> "Dev B" 브랜치의 풀 리퀘스트를 검토하고 병합합니다.</li>
<li><b>GitHub에서 풀 리퀘스트 생성 (Dev A -&gt; Main):</b> GitHub에서 "Dev A" 브랜치를 "Main" 브랜치에 병합하기 위한 풀 리퀘스트를 생성합니다.</li>
<li><b>코드 충돌 해결 (Dev A):</b> 만약 코드 충돌이 발생하면, "Main" 브랜치를 "Dev A" 브랜치에 병합하고, 충돌을 해결합니다.</li>
</ol>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>git pull origin main</li>
</ul>
<ol style="list-style-type: decimal;" data-ke-list-type="decimal">
<li><b>AI 에이전트에게 충돌 해결 요청:</b> 충돌 해결을 위해 커서 AI 에이전트에게 도움을 요청합니다.</li>
</ol>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li><b>프롬프트 예시</b>: "Git 충돌을 해결하여 두 게임을 모두 포함해주세요."</li>
</ul>
<ol style="list-style-type: decimal;" data-ke-list-type="decimal">
<li><b>충돌 해결 코드 검토:</b> AI 에이전트가 제시한 충돌 해결 코드를 검토하고 수정합니다.</li>
<li><b>충돌 해결 코드 커밋 및 푸시 (Dev A):</b> 충돌이 해결된 코드를 커밋하고 "Dev A" 브랜치에 푸시합니다.</li>
<li><b>풀 리퀘스트 병합 (Dev A -&gt; Main):</b> "Dev A" 브랜치의 풀 리퀘스트를 검토하고 병합합니다.</li>
<li><b>로컬 저장소 업데이트:</b> 로컬 저장소의 메인 브랜치를 최신 상태로 업데이트합니다.</li>
</ol>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>git pull origin main</li>
</ul>
<ol style="list-style-type: decimal;" data-ke-list-type="decimal">
<li><b>새로운 기능 개발 반복:</b> 새로운 기능을 개발하기 위해 위 단계를 반복합니다.</li>
</ol>
<h2 data-ke-size="size26">4. "더블 에이전트" 핵 사용 팁</h2>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li><b>동일한 파일 작업 최소화:</b> AI 에이전트들이 동일한 파일을 작업하는 상황을 최대한 피하여 코드 충돌을 줄입니다.</li>
<li><b>코드 충돌 해결 연습:</b> 코드 충돌 해결은 개발자의 필수 역량입니다. "더블 에이전트" 핵을 통해 코드 충돌 해결 능력을 향상시킬 수 있습니다.</li>
<li><b>커서 AI 에이전트 설정 확인:</b> 작업 지시를 내리기 전에 커서 AI 에이전트가 활성화되었는지, 올바른 파일이 선택되었는지 확인합니다.</li>
</ul>
<h2 data-ke-size="size26">5. 결론: 코딩 생산성 2배 향상, 지금 바로 "더블 에이전트" 핵을 사용해보세요!</h2>
<p data-ke-size="size16">"더블 에이전트" 핵은 커서 AI 에이전트의 잠재력을 최대한 활용하여 코딩 생산성을 2배로 향상시킬 수 있는 혁신적인 방법입니다. GitHub, Git Worktree, 그리고 커서 AI 에이전트를 능숙하게 활용하여 꿈꿔왔던 프로젝트를 더 빠르고 효율적으로 현실로 만들어보세요!</p>
<p data-ke-size="size16"><b>프롬프트 예시 요약:</b></p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li><b>(새 코드 구현):</b> "$$게임 이름]을 구현하고, 이 파일을 중앙 파일과 통합해주세요."</li>
<li><b>(Git 충돌 해결):</b> "Git 충돌을 해결하여 두 게임을 모두 포함해주세요."</li>
</ul>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>I. Initial Setup and Workflow Demonstrations</b></p>
<ol style="list-style-type: decimal;" data-ke-list-type="decimal">
<li><b>(To Cursor Agent A - Implied):</b> "Please go ahead and implement the Tetris game and make sure it's integrated with this main file."</li>
<li><b>(To Cursor Agent B - Implied):</b> "Please go ahead and implement the Mind sweeper game and make sure it's integrated with this main file."</li>
<li><b>(To Cursor - Explicit):</b> (Via voice assistant or command line) "We are currently looking at a template repository and we want to completely gut and replace this with a game Center sort of application that will have games like Tic taac toe memory and so on can you please Implement a basic shell for this sort of repository oh and we're going to want to use the composer agent".</li>
<li><b>(To Cursor - Explicit):</b> "get add everything then here's the commit message and then hit push origin main". (The user tells the AI to write this command, it is not necessarily running it).</li>
<li><b>(To Cursor Agent B - Explicit):</b> "please use port 5175". (When changing the port)</li>
</ol>
<p data-ke-size="size16"><b>II. Resolving Merge Conflicts</b></p>
<ol style="list-style-type: decimal;" data-ke-list-type="decimal">
<li><b>(To Cursor Agent A - Explicit):</b> "Please resolve the git conflicts to include both games".</li>
</ol>
<p data-ke-size="size16"><b>Important Notes:</b></p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>Many of the prompts are implied by the speaker's actions. They are telling the AI to do things but not necessarily writing out a detailed prompt.</li>
<li>The video heavily relies on iteration. The initial prompts get the AI started, and the user then inspects the code, identifies problems, and provides further instructions.</li>
<li>This technique leverages the AI's ability to integrate new code into existing projects. The prompts emphasize this aspect.</li>
</ul>
<p data-ke-size="size16"><b>Detailed Breakdown &amp; Explanation</b></p>
<p data-ke-size="size16">The video revolves around efficiently using two AI agents in parallel. Therefore, understanding the workflow is crucial for grasping the prompts.</p>
<ol style="list-style-type: decimal;" data-ke-list-type="decimal">
<li><b>Core Concept:</b> The user establishes a shared codebase on GitHub.</li>
<li><b>Branching:</b> They create two development branches (DevA and DevB).</li>
<li><b>Git Worktrees:</b> They use Git Worktrees to create separate folders on their local machine, each linked to one of the development branches.</li>
<li><b>Parallel Development:</b> They open two instances of Cursor, each pointing to one of the worktree folders.</li>
<li><b>Independent Agents:</b> They assign each Cursor instance (each AI agent) a different task:
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>Agent A: Implement Tetris</li>
<li>Agent B: Implement Minesweeper</li>
</ul>
</li>
<li><b>Code Merging &amp; Conflict Resolution:</b> After the agents generate code, the user merges the branches back into the main branch, resolving any conflicts along the way (with AI assistance if needed).</li>
</ol>
<p data-ke-size="size16"><b>Therefore, the prompts are designed to leverage this workflow:</b></p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>The initial prompts are relatively high-level: "Implement X and integrate it." The AI agent is expected to handle the details of the implementation.</li>
<li>The user trusts the AI to generate reasonable code for each game, focusing on the integration aspect.</li>
<li>When conflicts arise, the user provides a targeted prompt to resolve them: "Resolve the Git conflicts to include both games."</li>
</ul>
<p data-ke-size="size16"><b>In Summary</b></p>
<p data-ke-size="size16">This "Double Agent" hack isn't just about writing code faster; it's about structuring your workflow to parallelize the development process, enabling you to leverage the power of AI for multiple tasks simultaneously. The prompts themselves are fairly straightforward, but the key is understanding the underlying Git and GitHub workflow that makes it all possible.</p>
                        </div>
                        <br/>
                        <div class="tags">
                            
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
